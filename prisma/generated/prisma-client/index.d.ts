// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  bid: (where?: BidWhereInput) => Promise<boolean>;
  claim: (where?: ClaimWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  region: (where?: RegionWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  serviceItem: (where?: ServiceItemWhereInput) => Promise<boolean>;
  specialty: (where?: SpecialtyWhereInput) => Promise<boolean>;
  specialtyItem: (where?: SpecialtyItemWhereInput) => Promise<boolean>;
  study: (where?: StudyWhereInput) => Promise<boolean>;
  therapeutic: (where?: TherapeuticWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bid: (where: BidWhereUniqueInput) => BidNullablePromise;
  bids: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bid>;
  bidsConnection: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BidConnectionPromise;
  claim: (where: ClaimWhereUniqueInput) => ClaimNullablePromise;
  claims: (args?: {
    where?: ClaimWhereInput;
    orderBy?: ClaimOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Claim>;
  claimsConnection: (args?: {
    where?: ClaimWhereInput;
    orderBy?: ClaimOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClaimConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  region: (where: RegionWhereUniqueInput) => RegionNullablePromise;
  regions: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Region>;
  regionsConnection: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegionConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServiceNullablePromise;
  services: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Service>;
  servicesConnection: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceConnectionPromise;
  serviceItem: (
    where: ServiceItemWhereUniqueInput
  ) => ServiceItemNullablePromise;
  serviceItems: (args?: {
    where?: ServiceItemWhereInput;
    orderBy?: ServiceItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ServiceItem>;
  serviceItemsConnection: (args?: {
    where?: ServiceItemWhereInput;
    orderBy?: ServiceItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceItemConnectionPromise;
  specialty: (where: SpecialtyWhereUniqueInput) => SpecialtyNullablePromise;
  specialties: (args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Specialty>;
  specialtiesConnection: (args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpecialtyConnectionPromise;
  specialtyItem: (
    where: SpecialtyItemWhereUniqueInput
  ) => SpecialtyItemNullablePromise;
  specialtyItems: (args?: {
    where?: SpecialtyItemWhereInput;
    orderBy?: SpecialtyItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SpecialtyItem>;
  specialtyItemsConnection: (args?: {
    where?: SpecialtyItemWhereInput;
    orderBy?: SpecialtyItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpecialtyItemConnectionPromise;
  study: (where: StudyWhereUniqueInput) => StudyNullablePromise;
  studies: (args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Study>;
  studiesConnection: (args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudyConnectionPromise;
  therapeutic: (
    where: TherapeuticWhereUniqueInput
  ) => TherapeuticNullablePromise;
  therapeutics: (args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Therapeutic>;
  therapeuticsConnection: (args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TherapeuticConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBid: (data: BidCreateInput) => BidPromise;
  updateBid: (args: {
    data: BidUpdateInput;
    where: BidWhereUniqueInput;
  }) => BidPromise;
  updateManyBids: (args: {
    data: BidUpdateManyMutationInput;
    where?: BidWhereInput;
  }) => BatchPayloadPromise;
  upsertBid: (args: {
    where: BidWhereUniqueInput;
    create: BidCreateInput;
    update: BidUpdateInput;
  }) => BidPromise;
  deleteBid: (where: BidWhereUniqueInput) => BidPromise;
  deleteManyBids: (where?: BidWhereInput) => BatchPayloadPromise;
  createClaim: (data: ClaimCreateInput) => ClaimPromise;
  updateClaim: (args: {
    data: ClaimUpdateInput;
    where: ClaimWhereUniqueInput;
  }) => ClaimPromise;
  updateManyClaims: (args: {
    data: ClaimUpdateManyMutationInput;
    where?: ClaimWhereInput;
  }) => BatchPayloadPromise;
  upsertClaim: (args: {
    where: ClaimWhereUniqueInput;
    create: ClaimCreateInput;
    update: ClaimUpdateInput;
  }) => ClaimPromise;
  deleteClaim: (where: ClaimWhereUniqueInput) => ClaimPromise;
  deleteManyClaims: (where?: ClaimWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createRegion: (data: RegionCreateInput) => RegionPromise;
  updateRegion: (args: {
    data: RegionUpdateInput;
    where: RegionWhereUniqueInput;
  }) => RegionPromise;
  updateManyRegions: (args: {
    data: RegionUpdateManyMutationInput;
    where?: RegionWhereInput;
  }) => BatchPayloadPromise;
  upsertRegion: (args: {
    where: RegionWhereUniqueInput;
    create: RegionCreateInput;
    update: RegionUpdateInput;
  }) => RegionPromise;
  deleteRegion: (where: RegionWhereUniqueInput) => RegionPromise;
  deleteManyRegions: (where?: RegionWhereInput) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (args: {
    data: ServiceUpdateInput;
    where: ServiceWhereUniqueInput;
  }) => ServicePromise;
  upsertService: (args: {
    where: ServiceWhereUniqueInput;
    create: ServiceCreateInput;
    update: ServiceUpdateInput;
  }) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createServiceItem: (data: ServiceItemCreateInput) => ServiceItemPromise;
  updateServiceItem: (args: {
    data: ServiceItemUpdateInput;
    where: ServiceItemWhereUniqueInput;
  }) => ServiceItemPromise;
  updateManyServiceItems: (args: {
    data: ServiceItemUpdateManyMutationInput;
    where?: ServiceItemWhereInput;
  }) => BatchPayloadPromise;
  upsertServiceItem: (args: {
    where: ServiceItemWhereUniqueInput;
    create: ServiceItemCreateInput;
    update: ServiceItemUpdateInput;
  }) => ServiceItemPromise;
  deleteServiceItem: (where: ServiceItemWhereUniqueInput) => ServiceItemPromise;
  deleteManyServiceItems: (
    where?: ServiceItemWhereInput
  ) => BatchPayloadPromise;
  createSpecialty: (data: SpecialtyCreateInput) => SpecialtyPromise;
  updateSpecialty: (args: {
    data: SpecialtyUpdateInput;
    where: SpecialtyWhereUniqueInput;
  }) => SpecialtyPromise;
  upsertSpecialty: (args: {
    where: SpecialtyWhereUniqueInput;
    create: SpecialtyCreateInput;
    update: SpecialtyUpdateInput;
  }) => SpecialtyPromise;
  deleteSpecialty: (where: SpecialtyWhereUniqueInput) => SpecialtyPromise;
  deleteManySpecialties: (where?: SpecialtyWhereInput) => BatchPayloadPromise;
  createSpecialtyItem: (data: SpecialtyItemCreateInput) => SpecialtyItemPromise;
  updateSpecialtyItem: (args: {
    data: SpecialtyItemUpdateInput;
    where: SpecialtyItemWhereUniqueInput;
  }) => SpecialtyItemPromise;
  updateManySpecialtyItems: (args: {
    data: SpecialtyItemUpdateManyMutationInput;
    where?: SpecialtyItemWhereInput;
  }) => BatchPayloadPromise;
  upsertSpecialtyItem: (args: {
    where: SpecialtyItemWhereUniqueInput;
    create: SpecialtyItemCreateInput;
    update: SpecialtyItemUpdateInput;
  }) => SpecialtyItemPromise;
  deleteSpecialtyItem: (
    where: SpecialtyItemWhereUniqueInput
  ) => SpecialtyItemPromise;
  deleteManySpecialtyItems: (
    where?: SpecialtyItemWhereInput
  ) => BatchPayloadPromise;
  createStudy: (data: StudyCreateInput) => StudyPromise;
  updateStudy: (args: {
    data: StudyUpdateInput;
    where: StudyWhereUniqueInput;
  }) => StudyPromise;
  updateManyStudies: (args: {
    data: StudyUpdateManyMutationInput;
    where?: StudyWhereInput;
  }) => BatchPayloadPromise;
  upsertStudy: (args: {
    where: StudyWhereUniqueInput;
    create: StudyCreateInput;
    update: StudyUpdateInput;
  }) => StudyPromise;
  deleteStudy: (where: StudyWhereUniqueInput) => StudyPromise;
  deleteManyStudies: (where?: StudyWhereInput) => BatchPayloadPromise;
  createTherapeutic: (data: TherapeuticCreateInput) => TherapeuticPromise;
  updateTherapeutic: (args: {
    data: TherapeuticUpdateInput;
    where: TherapeuticWhereUniqueInput;
  }) => TherapeuticPromise;
  updateManyTherapeutics: (args: {
    data: TherapeuticUpdateManyMutationInput;
    where?: TherapeuticWhereInput;
  }) => BatchPayloadPromise;
  upsertTherapeutic: (args: {
    where: TherapeuticWhereUniqueInput;
    create: TherapeuticCreateInput;
    update: TherapeuticUpdateInput;
  }) => TherapeuticPromise;
  deleteTherapeutic: (where: TherapeuticWhereUniqueInput) => TherapeuticPromise;
  deleteManyTherapeutics: (
    where?: TherapeuticWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bid: (
    where?: BidSubscriptionWhereInput
  ) => BidSubscriptionPayloadSubscription;
  claim: (
    where?: ClaimSubscriptionWhereInput
  ) => ClaimSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  region: (
    where?: RegionSubscriptionWhereInput
  ) => RegionSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  serviceItem: (
    where?: ServiceItemSubscriptionWhereInput
  ) => ServiceItemSubscriptionPayloadSubscription;
  specialty: (
    where?: SpecialtySubscriptionWhereInput
  ) => SpecialtySubscriptionPayloadSubscription;
  specialtyItem: (
    where?: SpecialtyItemSubscriptionWhereInput
  ) => SpecialtyItemSubscriptionPayloadSubscription;
  study: (
    where?: StudySubscriptionWhereInput
  ) => StudySubscriptionPayloadSubscription;
  therapeutic: (
    where?: TherapeuticSubscriptionWhereInput
  ) => TherapeuticSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Phase = "I" | "II" | "III" | "IV";

export type CompanySize = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I";

export type ServiceOrderByInput = "id_ASC" | "id_DESC";

export type SpecialtyOrderByInput = "id_ASC" | "id_DESC";

export type RegionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "maintainer_ASC"
  | "maintainer_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "logoURL_ASC"
  | "logoURL_DESC"
  | "website_ASC"
  | "website_DESC"
  | "linkedin_ASC"
  | "linkedin_DESC"
  | "overview_ASC"
  | "overview_DESC"
  | "headquarters_ASC"
  | "headquarters_DESC"
  | "companySize_ASC"
  | "companySize_DESC";

export type TherapeuticOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type StudyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "area_ASC"
  | "area_DESC"
  | "protocol_number_ASC"
  | "protocol_number_DESC"
  | "title_ASC"
  | "title_DESC"
  | "phase_ASC"
  | "phase_DESC"
  | "services_ASC"
  | "services_DESC"
  | "modified_date_ASC"
  | "modified_date_DESC"
  | "status_ASC"
  | "status_DESC";

export type BidOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "bid_amount_ASC"
  | "bid_amount_DESC"
  | "is_approved_ASC"
  | "is_approved_DESC";

export type ClaimOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "user_ASC"
  | "user_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "pending_ASC"
  | "pending_DESC"
  | "approved_ASC"
  | "approved_DESC";

export type ServiceItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type SpecialtyItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BidWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ServiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  info?: Maybe<ServiceItemWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  specialties_every?: Maybe<SpecialtyWhereInput>;
  specialties_some?: Maybe<SpecialtyWhereInput>;
  specialties_none?: Maybe<SpecialtyWhereInput>;
  AND?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  OR?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  NOT?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
}

export interface ServiceItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ServiceItemWhereInput[] | ServiceItemWhereInput>;
  OR?: Maybe<ServiceItemWhereInput[] | ServiceItemWhereInput>;
  NOT?: Maybe<ServiceItemWhereInput[] | ServiceItemWhereInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  maintainer_not?: Maybe<String>;
  maintainer_in?: Maybe<String[] | String>;
  maintainer_not_in?: Maybe<String[] | String>;
  maintainer_lt?: Maybe<String>;
  maintainer_lte?: Maybe<String>;
  maintainer_gt?: Maybe<String>;
  maintainer_gte?: Maybe<String>;
  maintainer_contains?: Maybe<String>;
  maintainer_not_contains?: Maybe<String>;
  maintainer_starts_with?: Maybe<String>;
  maintainer_not_starts_with?: Maybe<String>;
  maintainer_ends_with?: Maybe<String>;
  maintainer_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  logoURL?: Maybe<String>;
  logoURL_not?: Maybe<String>;
  logoURL_in?: Maybe<String[] | String>;
  logoURL_not_in?: Maybe<String[] | String>;
  logoURL_lt?: Maybe<String>;
  logoURL_lte?: Maybe<String>;
  logoURL_gt?: Maybe<String>;
  logoURL_gte?: Maybe<String>;
  logoURL_contains?: Maybe<String>;
  logoURL_not_contains?: Maybe<String>;
  logoURL_starts_with?: Maybe<String>;
  logoURL_not_starts_with?: Maybe<String>;
  logoURL_ends_with?: Maybe<String>;
  logoURL_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  linkedin?: Maybe<String>;
  linkedin_not?: Maybe<String>;
  linkedin_in?: Maybe<String[] | String>;
  linkedin_not_in?: Maybe<String[] | String>;
  linkedin_lt?: Maybe<String>;
  linkedin_lte?: Maybe<String>;
  linkedin_gt?: Maybe<String>;
  linkedin_gte?: Maybe<String>;
  linkedin_contains?: Maybe<String>;
  linkedin_not_contains?: Maybe<String>;
  linkedin_starts_with?: Maybe<String>;
  linkedin_not_starts_with?: Maybe<String>;
  linkedin_ends_with?: Maybe<String>;
  linkedin_not_ends_with?: Maybe<String>;
  overview?: Maybe<String>;
  overview_not?: Maybe<String>;
  overview_in?: Maybe<String[] | String>;
  overview_not_in?: Maybe<String[] | String>;
  overview_lt?: Maybe<String>;
  overview_lte?: Maybe<String>;
  overview_gt?: Maybe<String>;
  overview_gte?: Maybe<String>;
  overview_contains?: Maybe<String>;
  overview_not_contains?: Maybe<String>;
  overview_starts_with?: Maybe<String>;
  overview_not_starts_with?: Maybe<String>;
  overview_ends_with?: Maybe<String>;
  overview_not_ends_with?: Maybe<String>;
  headquarters?: Maybe<String>;
  headquarters_not?: Maybe<String>;
  headquarters_in?: Maybe<String[] | String>;
  headquarters_not_in?: Maybe<String[] | String>;
  headquarters_lt?: Maybe<String>;
  headquarters_lte?: Maybe<String>;
  headquarters_gt?: Maybe<String>;
  headquarters_gte?: Maybe<String>;
  headquarters_contains?: Maybe<String>;
  headquarters_not_contains?: Maybe<String>;
  headquarters_starts_with?: Maybe<String>;
  headquarters_not_starts_with?: Maybe<String>;
  headquarters_ends_with?: Maybe<String>;
  headquarters_not_ends_with?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  companySize_not?: Maybe<CompanySize>;
  companySize_in?: Maybe<CompanySize[] | CompanySize>;
  companySize_not_in?: Maybe<CompanySize[] | CompanySize>;
  services_every?: Maybe<ServiceWhereInput>;
  services_some?: Maybe<ServiceWhereInput>;
  services_none?: Maybe<ServiceWhereInput>;
  regions_every?: Maybe<RegionWhereInput>;
  regions_some?: Maybe<RegionWhereInput>;
  regions_none?: Maybe<RegionWhereInput>;
  therapeutics_every?: Maybe<TherapeuticWhereInput>;
  therapeutics_some?: Maybe<TherapeuticWhereInput>;
  therapeutics_none?: Maybe<TherapeuticWhereInput>;
  studies_every?: Maybe<StudyWhereInput>;
  studies_some?: Maybe<StudyWhereInput>;
  studies_none?: Maybe<StudyWhereInput>;
  bids_every?: Maybe<BidWhereInput>;
  bids_some?: Maybe<BidWhereInput>;
  bids_none?: Maybe<BidWhereInput>;
  claims_every?: Maybe<ClaimWhereInput>;
  claims_some?: Maybe<ClaimWhereInput>;
  claims_none?: Maybe<ClaimWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface RegionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  companies_every?: Maybe<CompanyWhereInput>;
  companies_some?: Maybe<CompanyWhereInput>;
  companies_none?: Maybe<CompanyWhereInput>;
  AND?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  OR?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  NOT?: Maybe<RegionWhereInput[] | RegionWhereInput>;
}

export interface TherapeuticWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  companies_every?: Maybe<CompanyWhereInput>;
  companies_some?: Maybe<CompanyWhereInput>;
  companies_none?: Maybe<CompanyWhereInput>;
  AND?: Maybe<TherapeuticWhereInput[] | TherapeuticWhereInput>;
  OR?: Maybe<TherapeuticWhereInput[] | TherapeuticWhereInput>;
  NOT?: Maybe<TherapeuticWhereInput[] | TherapeuticWhereInput>;
}

export interface StudyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  protocol_number?: Maybe<String>;
  protocol_number_not?: Maybe<String>;
  protocol_number_in?: Maybe<String[] | String>;
  protocol_number_not_in?: Maybe<String[] | String>;
  protocol_number_lt?: Maybe<String>;
  protocol_number_lte?: Maybe<String>;
  protocol_number_gt?: Maybe<String>;
  protocol_number_gte?: Maybe<String>;
  protocol_number_contains?: Maybe<String>;
  protocol_number_not_contains?: Maybe<String>;
  protocol_number_starts_with?: Maybe<String>;
  protocol_number_not_starts_with?: Maybe<String>;
  protocol_number_ends_with?: Maybe<String>;
  protocol_number_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  phase?: Maybe<Int>;
  phase_not?: Maybe<Int>;
  phase_in?: Maybe<Int[] | Int>;
  phase_not_in?: Maybe<Int[] | Int>;
  phase_lt?: Maybe<Int>;
  phase_lte?: Maybe<Int>;
  phase_gt?: Maybe<Int>;
  phase_gte?: Maybe<Int>;
  services?: Maybe<Int>;
  services_not?: Maybe<Int>;
  services_in?: Maybe<Int[] | Int>;
  services_not_in?: Maybe<Int[] | Int>;
  services_lt?: Maybe<Int>;
  services_lte?: Maybe<Int>;
  services_gt?: Maybe<Int>;
  services_gte?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  modified_date_not?: Maybe<DateTimeInput>;
  modified_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_lt?: Maybe<DateTimeInput>;
  modified_date_lte?: Maybe<DateTimeInput>;
  modified_date_gt?: Maybe<DateTimeInput>;
  modified_date_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  AND?: Maybe<StudyWhereInput[] | StudyWhereInput>;
  OR?: Maybe<StudyWhereInput[] | StudyWhereInput>;
  NOT?: Maybe<StudyWhereInput[] | StudyWhereInput>;
}

export interface BidWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  bid_amount?: Maybe<Float>;
  bid_amount_not?: Maybe<Float>;
  bid_amount_in?: Maybe<Float[] | Float>;
  bid_amount_not_in?: Maybe<Float[] | Float>;
  bid_amount_lt?: Maybe<Float>;
  bid_amount_lte?: Maybe<Float>;
  bid_amount_gt?: Maybe<Float>;
  bid_amount_gte?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  is_approved_not?: Maybe<Boolean>;
  study?: Maybe<StudyWhereInput>;
  AND?: Maybe<BidWhereInput[] | BidWhereInput>;
  OR?: Maybe<BidWhereInput[] | BidWhereInput>;
  NOT?: Maybe<BidWhereInput[] | BidWhereInput>;
}

export interface ClaimWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<String>;
  user_not?: Maybe<String>;
  user_in?: Maybe<String[] | String>;
  user_not_in?: Maybe<String[] | String>;
  user_lt?: Maybe<String>;
  user_lte?: Maybe<String>;
  user_gt?: Maybe<String>;
  user_gte?: Maybe<String>;
  user_contains?: Maybe<String>;
  user_not_contains?: Maybe<String>;
  user_starts_with?: Maybe<String>;
  user_not_starts_with?: Maybe<String>;
  user_ends_with?: Maybe<String>;
  user_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  pending?: Maybe<Boolean>;
  pending_not?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  approved_not?: Maybe<Boolean>;
  AND?: Maybe<ClaimWhereInput[] | ClaimWhereInput>;
  OR?: Maybe<ClaimWhereInput[] | ClaimWhereInput>;
  NOT?: Maybe<ClaimWhereInput[] | ClaimWhereInput>;
}

export interface SpecialtyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  info?: Maybe<SpecialtyItemWhereInput>;
  service?: Maybe<ServiceWhereInput>;
  sub_specialties_every?: Maybe<SpecialtyWhereInput>;
  sub_specialties_some?: Maybe<SpecialtyWhereInput>;
  sub_specialties_none?: Maybe<SpecialtyWhereInput>;
  AND?: Maybe<SpecialtyWhereInput[] | SpecialtyWhereInput>;
  OR?: Maybe<SpecialtyWhereInput[] | SpecialtyWhereInput>;
  NOT?: Maybe<SpecialtyWhereInput[] | SpecialtyWhereInput>;
}

export interface SpecialtyItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SpecialtyItemWhereInput[] | SpecialtyItemWhereInput>;
  OR?: Maybe<SpecialtyItemWhereInput[] | SpecialtyItemWhereInput>;
  NOT?: Maybe<SpecialtyItemWhereInput[] | SpecialtyItemWhereInput>;
}

export type ClaimWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type RegionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ServiceItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type SpecialtyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SpecialtyItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type StudyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type TherapeuticWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface BidCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneWithoutBidsInput;
  bid_amount: Float;
  is_approved?: Maybe<Boolean>;
  study: StudyCreateOneInput;
}

export interface CompanyCreateOneWithoutBidsInput {
  create?: Maybe<CompanyCreateWithoutBidsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutBidsInput {
  id?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompanyInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimCreateManyWithoutCompanyInput>;
}

export interface CompanyCreatephasesInput {
  set?: Maybe<Phase[] | Phase>;
}

export interface ServiceCreateManyWithoutCompanyInput {
  create?: Maybe<
    ServiceCreateWithoutCompanyInput[] | ServiceCreateWithoutCompanyInput
  >;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  info: ServiceItemCreateOneInput;
  specialties?: Maybe<SpecialtyCreateManyWithoutServiceInput>;
}

export interface ServiceItemCreateOneInput {
  create?: Maybe<ServiceItemCreateInput>;
  connect?: Maybe<ServiceItemWhereUniqueInput>;
}

export interface ServiceItemCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface SpecialtyCreateManyWithoutServiceInput {
  create?: Maybe<
    SpecialtyCreateWithoutServiceInput[] | SpecialtyCreateWithoutServiceInput
  >;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
}

export interface SpecialtyCreateWithoutServiceInput {
  id?: Maybe<ID_Input>;
  info: SpecialtyItemCreateOneInput;
  sub_specialties?: Maybe<SpecialtyCreateManyInput>;
}

export interface SpecialtyItemCreateOneInput {
  create?: Maybe<SpecialtyItemCreateInput>;
  connect?: Maybe<SpecialtyItemWhereUniqueInput>;
}

export interface SpecialtyItemCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface SpecialtyCreateManyInput {
  create?: Maybe<SpecialtyCreateInput[] | SpecialtyCreateInput>;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
}

export interface SpecialtyCreateInput {
  id?: Maybe<ID_Input>;
  info: SpecialtyItemCreateOneInput;
  service?: Maybe<ServiceCreateOneWithoutSpecialtiesInput>;
  sub_specialties?: Maybe<SpecialtyCreateManyInput>;
}

export interface ServiceCreateOneWithoutSpecialtiesInput {
  create?: Maybe<ServiceCreateWithoutSpecialtiesInput>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutSpecialtiesInput {
  id?: Maybe<ID_Input>;
  info: ServiceItemCreateOneInput;
  company: CompanyCreateOneWithoutServicesInput;
}

export interface CompanyCreateOneWithoutServicesInput {
  create?: Maybe<CompanyCreateWithoutServicesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutServicesInput {
  id?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimCreateManyWithoutCompanyInput>;
}

export interface RegionCreateManyWithoutCompaniesInput {
  create?: Maybe<
    RegionCreateWithoutCompaniesInput[] | RegionCreateWithoutCompaniesInput
  >;
  connect?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
}

export interface RegionCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface TherapeuticCreateManyWithoutCompaniesInput {
  create?: Maybe<
    | TherapeuticCreateWithoutCompaniesInput[]
    | TherapeuticCreateWithoutCompaniesInput
  >;
  connect?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
}

export interface TherapeuticCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface StudyCreateManyWithoutCompanyInput {
  create?: Maybe<
    StudyCreateWithoutCompanyInput[] | StudyCreateWithoutCompanyInput
  >;
  connect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
}

export interface StudyCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeInput;
  status: String;
}

export interface BidCreateManyWithoutCompanyInput {
  create?: Maybe<BidCreateWithoutCompanyInput[] | BidCreateWithoutCompanyInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
}

export interface BidCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  bid_amount: Float;
  is_approved?: Maybe<Boolean>;
  study: StudyCreateOneInput;
}

export interface StudyCreateOneInput {
  create?: Maybe<StudyCreateInput>;
  connect?: Maybe<StudyWhereUniqueInput>;
}

export interface StudyCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeInput;
  status: String;
  company: CompanyCreateOneWithoutStudiesInput;
}

export interface CompanyCreateOneWithoutStudiesInput {
  create?: Maybe<CompanyCreateWithoutStudiesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutStudiesInput {
  id?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompanyInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimCreateManyWithoutCompanyInput>;
}

export interface ClaimCreateManyWithoutCompanyInput {
  create?: Maybe<
    ClaimCreateWithoutCompanyInput[] | ClaimCreateWithoutCompanyInput
  >;
  connect?: Maybe<ClaimWhereUniqueInput[] | ClaimWhereUniqueInput>;
}

export interface ClaimCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  user: String;
  email: String;
  name: String;
  pending?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
}

export interface BidUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutBidsInput>;
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  study?: Maybe<StudyUpdateOneRequiredInput>;
}

export interface CompanyUpdateOneRequiredWithoutBidsInput {
  create?: Maybe<CompanyCreateWithoutBidsInput>;
  update?: Maybe<CompanyUpdateWithoutBidsDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutBidsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutBidsDataInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompanyInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpdatephasesInput {
  set?: Maybe<Phase[] | Phase>;
}

export interface ServiceUpdateManyWithoutCompanyInput {
  create?: Maybe<
    ServiceCreateWithoutCompanyInput[] | ServiceCreateWithoutCompanyInput
  >;
  delete?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  set?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  disconnect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  update?: Maybe<
    | ServiceUpdateWithWhereUniqueWithoutCompanyInput[]
    | ServiceUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | ServiceUpsertWithWhereUniqueWithoutCompanyInput[]
    | ServiceUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
}

export interface ServiceUpdateWithWhereUniqueWithoutCompanyInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateWithoutCompanyDataInput;
}

export interface ServiceUpdateWithoutCompanyDataInput {
  info?: Maybe<ServiceItemUpdateOneRequiredInput>;
  specialties?: Maybe<SpecialtyUpdateManyWithoutServiceInput>;
}

export interface ServiceItemUpdateOneRequiredInput {
  create?: Maybe<ServiceItemCreateInput>;
  update?: Maybe<ServiceItemUpdateDataInput>;
  upsert?: Maybe<ServiceItemUpsertNestedInput>;
  connect?: Maybe<ServiceItemWhereUniqueInput>;
}

export interface ServiceItemUpdateDataInput {
  name?: Maybe<String>;
}

export interface ServiceItemUpsertNestedInput {
  update: ServiceItemUpdateDataInput;
  create: ServiceItemCreateInput;
}

export interface SpecialtyUpdateManyWithoutServiceInput {
  create?: Maybe<
    SpecialtyCreateWithoutServiceInput[] | SpecialtyCreateWithoutServiceInput
  >;
  delete?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  set?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  disconnect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  update?: Maybe<
    | SpecialtyUpdateWithWhereUniqueWithoutServiceInput[]
    | SpecialtyUpdateWithWhereUniqueWithoutServiceInput
  >;
  upsert?: Maybe<
    | SpecialtyUpsertWithWhereUniqueWithoutServiceInput[]
    | SpecialtyUpsertWithWhereUniqueWithoutServiceInput
  >;
  deleteMany?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
}

export interface SpecialtyUpdateWithWhereUniqueWithoutServiceInput {
  where: SpecialtyWhereUniqueInput;
  data: SpecialtyUpdateWithoutServiceDataInput;
}

export interface SpecialtyUpdateWithoutServiceDataInput {
  info?: Maybe<SpecialtyItemUpdateOneRequiredInput>;
  sub_specialties?: Maybe<SpecialtyUpdateManyInput>;
}

export interface SpecialtyItemUpdateOneRequiredInput {
  create?: Maybe<SpecialtyItemCreateInput>;
  update?: Maybe<SpecialtyItemUpdateDataInput>;
  upsert?: Maybe<SpecialtyItemUpsertNestedInput>;
  connect?: Maybe<SpecialtyItemWhereUniqueInput>;
}

export interface SpecialtyItemUpdateDataInput {
  name?: Maybe<String>;
}

export interface SpecialtyItemUpsertNestedInput {
  update: SpecialtyItemUpdateDataInput;
  create: SpecialtyItemCreateInput;
}

export interface SpecialtyUpdateManyInput {
  create?: Maybe<SpecialtyCreateInput[] | SpecialtyCreateInput>;
  update?: Maybe<
    | SpecialtyUpdateWithWhereUniqueNestedInput[]
    | SpecialtyUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SpecialtyUpsertWithWhereUniqueNestedInput[]
    | SpecialtyUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  set?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  disconnect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  deleteMany?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
}

export interface SpecialtyUpdateWithWhereUniqueNestedInput {
  where: SpecialtyWhereUniqueInput;
  data: SpecialtyUpdateDataInput;
}

export interface SpecialtyUpdateDataInput {
  info?: Maybe<SpecialtyItemUpdateOneRequiredInput>;
  service?: Maybe<ServiceUpdateOneWithoutSpecialtiesInput>;
  sub_specialties?: Maybe<SpecialtyUpdateManyInput>;
}

export interface ServiceUpdateOneWithoutSpecialtiesInput {
  create?: Maybe<ServiceCreateWithoutSpecialtiesInput>;
  update?: Maybe<ServiceUpdateWithoutSpecialtiesDataInput>;
  upsert?: Maybe<ServiceUpsertWithoutSpecialtiesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface ServiceUpdateWithoutSpecialtiesDataInput {
  info?: Maybe<ServiceItemUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutServicesInput>;
}

export interface CompanyUpdateOneRequiredWithoutServicesInput {
  create?: Maybe<CompanyCreateWithoutServicesInput>;
  update?: Maybe<CompanyUpdateWithoutServicesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutServicesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutServicesDataInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimUpdateManyWithoutCompanyInput>;
}

export interface RegionUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    RegionCreateWithoutCompaniesInput[] | RegionCreateWithoutCompaniesInput
  >;
  delete?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  connect?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  set?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  disconnect?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  update?: Maybe<
    | RegionUpdateWithWhereUniqueWithoutCompaniesInput[]
    | RegionUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | RegionUpsertWithWhereUniqueWithoutCompaniesInput[]
    | RegionUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
  updateMany?: Maybe<
    | RegionUpdateManyWithWhereNestedInput[]
    | RegionUpdateManyWithWhereNestedInput
  >;
}

export interface RegionUpdateWithWhereUniqueWithoutCompaniesInput {
  where: RegionWhereUniqueInput;
  data: RegionUpdateWithoutCompaniesDataInput;
}

export interface RegionUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
}

export interface RegionUpsertWithWhereUniqueWithoutCompaniesInput {
  where: RegionWhereUniqueInput;
  update: RegionUpdateWithoutCompaniesDataInput;
  create: RegionCreateWithoutCompaniesInput;
}

export interface RegionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
  OR?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
  NOT?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
}

export interface RegionUpdateManyWithWhereNestedInput {
  where: RegionScalarWhereInput;
  data: RegionUpdateManyDataInput;
}

export interface RegionUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TherapeuticUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    | TherapeuticCreateWithoutCompaniesInput[]
    | TherapeuticCreateWithoutCompaniesInput
  >;
  delete?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
  connect?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
  set?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
  disconnect?: Maybe<
    TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput
  >;
  update?: Maybe<
    | TherapeuticUpdateWithWhereUniqueWithoutCompaniesInput[]
    | TherapeuticUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | TherapeuticUpsertWithWhereUniqueWithoutCompaniesInput[]
    | TherapeuticUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<
    TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput
  >;
  updateMany?: Maybe<
    | TherapeuticUpdateManyWithWhereNestedInput[]
    | TherapeuticUpdateManyWithWhereNestedInput
  >;
}

export interface TherapeuticUpdateWithWhereUniqueWithoutCompaniesInput {
  where: TherapeuticWhereUniqueInput;
  data: TherapeuticUpdateWithoutCompaniesDataInput;
}

export interface TherapeuticUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
}

export interface TherapeuticUpsertWithWhereUniqueWithoutCompaniesInput {
  where: TherapeuticWhereUniqueInput;
  update: TherapeuticUpdateWithoutCompaniesDataInput;
  create: TherapeuticCreateWithoutCompaniesInput;
}

export interface TherapeuticScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput>;
  OR?: Maybe<TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput>;
  NOT?: Maybe<TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput>;
}

export interface TherapeuticUpdateManyWithWhereNestedInput {
  where: TherapeuticScalarWhereInput;
  data: TherapeuticUpdateManyDataInput;
}

export interface TherapeuticUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface StudyUpdateManyWithoutCompanyInput {
  create?: Maybe<
    StudyCreateWithoutCompanyInput[] | StudyCreateWithoutCompanyInput
  >;
  delete?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  connect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  set?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  disconnect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  update?: Maybe<
    | StudyUpdateWithWhereUniqueWithoutCompanyInput[]
    | StudyUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | StudyUpsertWithWhereUniqueWithoutCompanyInput[]
    | StudyUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  updateMany?: Maybe<
    StudyUpdateManyWithWhereNestedInput[] | StudyUpdateManyWithWhereNestedInput
  >;
}

export interface StudyUpdateWithWhereUniqueWithoutCompanyInput {
  where: StudyWhereUniqueInput;
  data: StudyUpdateWithoutCompanyDataInput;
}

export interface StudyUpdateWithoutCompanyDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface StudyUpsertWithWhereUniqueWithoutCompanyInput {
  where: StudyWhereUniqueInput;
  update: StudyUpdateWithoutCompanyDataInput;
  create: StudyCreateWithoutCompanyInput;
}

export interface StudyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  protocol_number?: Maybe<String>;
  protocol_number_not?: Maybe<String>;
  protocol_number_in?: Maybe<String[] | String>;
  protocol_number_not_in?: Maybe<String[] | String>;
  protocol_number_lt?: Maybe<String>;
  protocol_number_lte?: Maybe<String>;
  protocol_number_gt?: Maybe<String>;
  protocol_number_gte?: Maybe<String>;
  protocol_number_contains?: Maybe<String>;
  protocol_number_not_contains?: Maybe<String>;
  protocol_number_starts_with?: Maybe<String>;
  protocol_number_not_starts_with?: Maybe<String>;
  protocol_number_ends_with?: Maybe<String>;
  protocol_number_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  phase?: Maybe<Int>;
  phase_not?: Maybe<Int>;
  phase_in?: Maybe<Int[] | Int>;
  phase_not_in?: Maybe<Int[] | Int>;
  phase_lt?: Maybe<Int>;
  phase_lte?: Maybe<Int>;
  phase_gt?: Maybe<Int>;
  phase_gte?: Maybe<Int>;
  services?: Maybe<Int>;
  services_not?: Maybe<Int>;
  services_in?: Maybe<Int[] | Int>;
  services_not_in?: Maybe<Int[] | Int>;
  services_lt?: Maybe<Int>;
  services_lte?: Maybe<Int>;
  services_gt?: Maybe<Int>;
  services_gte?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  modified_date_not?: Maybe<DateTimeInput>;
  modified_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_lt?: Maybe<DateTimeInput>;
  modified_date_lte?: Maybe<DateTimeInput>;
  modified_date_gt?: Maybe<DateTimeInput>;
  modified_date_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  OR?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  NOT?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
}

export interface StudyUpdateManyWithWhereNestedInput {
  where: StudyScalarWhereInput;
  data: StudyUpdateManyDataInput;
}

export interface StudyUpdateManyDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface BidUpdateManyWithoutCompanyInput {
  create?: Maybe<BidCreateWithoutCompanyInput[] | BidCreateWithoutCompanyInput>;
  delete?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  set?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  disconnect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  update?: Maybe<
    | BidUpdateWithWhereUniqueWithoutCompanyInput[]
    | BidUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | BidUpsertWithWhereUniqueWithoutCompanyInput[]
    | BidUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  updateMany?: Maybe<
    BidUpdateManyWithWhereNestedInput[] | BidUpdateManyWithWhereNestedInput
  >;
}

export interface BidUpdateWithWhereUniqueWithoutCompanyInput {
  where: BidWhereUniqueInput;
  data: BidUpdateWithoutCompanyDataInput;
}

export interface BidUpdateWithoutCompanyDataInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  study?: Maybe<StudyUpdateOneRequiredInput>;
}

export interface StudyUpdateOneRequiredInput {
  create?: Maybe<StudyCreateInput>;
  update?: Maybe<StudyUpdateDataInput>;
  upsert?: Maybe<StudyUpsertNestedInput>;
  connect?: Maybe<StudyWhereUniqueInput>;
}

export interface StudyUpdateDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutStudiesInput>;
}

export interface CompanyUpdateOneRequiredWithoutStudiesInput {
  create?: Maybe<CompanyCreateWithoutStudiesInput>;
  update?: Maybe<CompanyUpdateWithoutStudiesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutStudiesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutStudiesDataInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompanyInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimUpdateManyWithoutCompanyInput>;
}

export interface ClaimUpdateManyWithoutCompanyInput {
  create?: Maybe<
    ClaimCreateWithoutCompanyInput[] | ClaimCreateWithoutCompanyInput
  >;
  delete?: Maybe<ClaimWhereUniqueInput[] | ClaimWhereUniqueInput>;
  connect?: Maybe<ClaimWhereUniqueInput[] | ClaimWhereUniqueInput>;
  set?: Maybe<ClaimWhereUniqueInput[] | ClaimWhereUniqueInput>;
  disconnect?: Maybe<ClaimWhereUniqueInput[] | ClaimWhereUniqueInput>;
  update?: Maybe<
    | ClaimUpdateWithWhereUniqueWithoutCompanyInput[]
    | ClaimUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | ClaimUpsertWithWhereUniqueWithoutCompanyInput[]
    | ClaimUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<ClaimScalarWhereInput[] | ClaimScalarWhereInput>;
  updateMany?: Maybe<
    ClaimUpdateManyWithWhereNestedInput[] | ClaimUpdateManyWithWhereNestedInput
  >;
}

export interface ClaimUpdateWithWhereUniqueWithoutCompanyInput {
  where: ClaimWhereUniqueInput;
  data: ClaimUpdateWithoutCompanyDataInput;
}

export interface ClaimUpdateWithoutCompanyDataInput {
  user?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  pending?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
}

export interface ClaimUpsertWithWhereUniqueWithoutCompanyInput {
  where: ClaimWhereUniqueInput;
  update: ClaimUpdateWithoutCompanyDataInput;
  create: ClaimCreateWithoutCompanyInput;
}

export interface ClaimScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<String>;
  user_not?: Maybe<String>;
  user_in?: Maybe<String[] | String>;
  user_not_in?: Maybe<String[] | String>;
  user_lt?: Maybe<String>;
  user_lte?: Maybe<String>;
  user_gt?: Maybe<String>;
  user_gte?: Maybe<String>;
  user_contains?: Maybe<String>;
  user_not_contains?: Maybe<String>;
  user_starts_with?: Maybe<String>;
  user_not_starts_with?: Maybe<String>;
  user_ends_with?: Maybe<String>;
  user_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  pending?: Maybe<Boolean>;
  pending_not?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
  approved_not?: Maybe<Boolean>;
  AND?: Maybe<ClaimScalarWhereInput[] | ClaimScalarWhereInput>;
  OR?: Maybe<ClaimScalarWhereInput[] | ClaimScalarWhereInput>;
  NOT?: Maybe<ClaimScalarWhereInput[] | ClaimScalarWhereInput>;
}

export interface ClaimUpdateManyWithWhereNestedInput {
  where: ClaimScalarWhereInput;
  data: ClaimUpdateManyDataInput;
}

export interface ClaimUpdateManyDataInput {
  user?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  pending?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
}

export interface CompanyUpsertWithoutStudiesInput {
  update: CompanyUpdateWithoutStudiesDataInput;
  create: CompanyCreateWithoutStudiesInput;
}

export interface StudyUpsertNestedInput {
  update: StudyUpdateDataInput;
  create: StudyCreateInput;
}

export interface BidUpsertWithWhereUniqueWithoutCompanyInput {
  where: BidWhereUniqueInput;
  update: BidUpdateWithoutCompanyDataInput;
  create: BidCreateWithoutCompanyInput;
}

export interface BidScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  bid_amount?: Maybe<Float>;
  bid_amount_not?: Maybe<Float>;
  bid_amount_in?: Maybe<Float[] | Float>;
  bid_amount_not_in?: Maybe<Float[] | Float>;
  bid_amount_lt?: Maybe<Float>;
  bid_amount_lte?: Maybe<Float>;
  bid_amount_gt?: Maybe<Float>;
  bid_amount_gte?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  is_approved_not?: Maybe<Boolean>;
  AND?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  OR?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  NOT?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
}

export interface BidUpdateManyWithWhereNestedInput {
  where: BidScalarWhereInput;
  data: BidUpdateManyDataInput;
}

export interface BidUpdateManyDataInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
}

export interface CompanyUpsertWithoutServicesInput {
  update: CompanyUpdateWithoutServicesDataInput;
  create: CompanyCreateWithoutServicesInput;
}

export interface ServiceUpsertWithoutSpecialtiesInput {
  update: ServiceUpdateWithoutSpecialtiesDataInput;
  create: ServiceCreateWithoutSpecialtiesInput;
}

export interface SpecialtyUpsertWithWhereUniqueNestedInput {
  where: SpecialtyWhereUniqueInput;
  update: SpecialtyUpdateDataInput;
  create: SpecialtyCreateInput;
}

export interface SpecialtyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
  OR?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
  NOT?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
}

export interface SpecialtyUpsertWithWhereUniqueWithoutServiceInput {
  where: SpecialtyWhereUniqueInput;
  update: SpecialtyUpdateWithoutServiceDataInput;
  create: SpecialtyCreateWithoutServiceInput;
}

export interface ServiceUpsertWithWhereUniqueWithoutCompanyInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateWithoutCompanyDataInput;
  create: ServiceCreateWithoutCompanyInput;
}

export interface ServiceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  OR?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  NOT?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
}

export interface CompanyUpsertWithoutBidsInput {
  update: CompanyUpdateWithoutBidsDataInput;
  create: CompanyCreateWithoutBidsInput;
}

export interface BidUpdateManyMutationInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
}

export interface ClaimCreateInput {
  id?: Maybe<ID_Input>;
  user: String;
  email: String;
  name: String;
  company: CompanyCreateOneWithoutClaimsInput;
  pending?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
}

export interface CompanyCreateOneWithoutClaimsInput {
  create?: Maybe<CompanyCreateWithoutClaimsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutClaimsInput {
  id?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompanyInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface ClaimUpdateInput {
  user?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutClaimsInput>;
  pending?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
}

export interface CompanyUpdateOneRequiredWithoutClaimsInput {
  create?: Maybe<CompanyCreateWithoutClaimsInput>;
  update?: Maybe<CompanyUpdateWithoutClaimsDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutClaimsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutClaimsDataInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompanyInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithoutClaimsInput {
  update: CompanyUpdateWithoutClaimsDataInput;
  create: CompanyCreateWithoutClaimsInput;
}

export interface ClaimUpdateManyMutationInput {
  user?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  pending?: Maybe<Boolean>;
  approved?: Maybe<Boolean>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompanyInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimCreateManyWithoutCompanyInput>;
}

export interface CompanyUpdateInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompanyInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpdateManyMutationInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
}

export interface RegionCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyWithoutRegionsInput>;
}

export interface CompanyCreateManyWithoutRegionsInput {
  create?: Maybe<
    CompanyCreateWithoutRegionsInput[] | CompanyCreateWithoutRegionsInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutRegionsInput {
  id?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompanyInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimCreateManyWithoutCompanyInput>;
}

export interface RegionUpdateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyWithoutRegionsInput>;
}

export interface CompanyUpdateManyWithoutRegionsInput {
  create?: Maybe<
    CompanyCreateWithoutRegionsInput[] | CompanyCreateWithoutRegionsInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutRegionsInput[]
    | CompanyUpdateWithWhereUniqueWithoutRegionsInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutRegionsInput[]
    | CompanyUpsertWithWhereUniqueWithoutRegionsInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutRegionsInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutRegionsDataInput;
}

export interface CompanyUpdateWithoutRegionsDataInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompanyInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutRegionsInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutRegionsDataInput;
  create: CompanyCreateWithoutRegionsInput;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  maintainer_not?: Maybe<String>;
  maintainer_in?: Maybe<String[] | String>;
  maintainer_not_in?: Maybe<String[] | String>;
  maintainer_lt?: Maybe<String>;
  maintainer_lte?: Maybe<String>;
  maintainer_gt?: Maybe<String>;
  maintainer_gte?: Maybe<String>;
  maintainer_contains?: Maybe<String>;
  maintainer_not_contains?: Maybe<String>;
  maintainer_starts_with?: Maybe<String>;
  maintainer_not_starts_with?: Maybe<String>;
  maintainer_ends_with?: Maybe<String>;
  maintainer_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  logoURL?: Maybe<String>;
  logoURL_not?: Maybe<String>;
  logoURL_in?: Maybe<String[] | String>;
  logoURL_not_in?: Maybe<String[] | String>;
  logoURL_lt?: Maybe<String>;
  logoURL_lte?: Maybe<String>;
  logoURL_gt?: Maybe<String>;
  logoURL_gte?: Maybe<String>;
  logoURL_contains?: Maybe<String>;
  logoURL_not_contains?: Maybe<String>;
  logoURL_starts_with?: Maybe<String>;
  logoURL_not_starts_with?: Maybe<String>;
  logoURL_ends_with?: Maybe<String>;
  logoURL_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  linkedin?: Maybe<String>;
  linkedin_not?: Maybe<String>;
  linkedin_in?: Maybe<String[] | String>;
  linkedin_not_in?: Maybe<String[] | String>;
  linkedin_lt?: Maybe<String>;
  linkedin_lte?: Maybe<String>;
  linkedin_gt?: Maybe<String>;
  linkedin_gte?: Maybe<String>;
  linkedin_contains?: Maybe<String>;
  linkedin_not_contains?: Maybe<String>;
  linkedin_starts_with?: Maybe<String>;
  linkedin_not_starts_with?: Maybe<String>;
  linkedin_ends_with?: Maybe<String>;
  linkedin_not_ends_with?: Maybe<String>;
  overview?: Maybe<String>;
  overview_not?: Maybe<String>;
  overview_in?: Maybe<String[] | String>;
  overview_not_in?: Maybe<String[] | String>;
  overview_lt?: Maybe<String>;
  overview_lte?: Maybe<String>;
  overview_gt?: Maybe<String>;
  overview_gte?: Maybe<String>;
  overview_contains?: Maybe<String>;
  overview_not_contains?: Maybe<String>;
  overview_starts_with?: Maybe<String>;
  overview_not_starts_with?: Maybe<String>;
  overview_ends_with?: Maybe<String>;
  overview_not_ends_with?: Maybe<String>;
  headquarters?: Maybe<String>;
  headquarters_not?: Maybe<String>;
  headquarters_in?: Maybe<String[] | String>;
  headquarters_not_in?: Maybe<String[] | String>;
  headquarters_lt?: Maybe<String>;
  headquarters_lte?: Maybe<String>;
  headquarters_gt?: Maybe<String>;
  headquarters_gte?: Maybe<String>;
  headquarters_contains?: Maybe<String>;
  headquarters_not_contains?: Maybe<String>;
  headquarters_starts_with?: Maybe<String>;
  headquarters_not_starts_with?: Maybe<String>;
  headquarters_ends_with?: Maybe<String>;
  headquarters_not_ends_with?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  companySize_not?: Maybe<CompanySize>;
  companySize_in?: Maybe<CompanySize[] | CompanySize>;
  companySize_not_in?: Maybe<CompanySize[] | CompanySize>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface CompanyUpdateManyDataInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
}

export interface RegionUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ServiceCreateInput {
  id?: Maybe<ID_Input>;
  info: ServiceItemCreateOneInput;
  company: CompanyCreateOneWithoutServicesInput;
  specialties?: Maybe<SpecialtyCreateManyWithoutServiceInput>;
}

export interface ServiceUpdateInput {
  info?: Maybe<ServiceItemUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutServicesInput>;
  specialties?: Maybe<SpecialtyUpdateManyWithoutServiceInput>;
}

export interface ServiceItemUpdateInput {
  name?: Maybe<String>;
}

export interface ServiceItemUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface SpecialtyUpdateInput {
  info?: Maybe<SpecialtyItemUpdateOneRequiredInput>;
  service?: Maybe<ServiceUpdateOneWithoutSpecialtiesInput>;
  sub_specialties?: Maybe<SpecialtyUpdateManyInput>;
}

export interface SpecialtyItemUpdateInput {
  name?: Maybe<String>;
}

export interface SpecialtyItemUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StudyUpdateInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutStudiesInput>;
}

export interface StudyUpdateManyMutationInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface TherapeuticCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyWithoutTherapeuticsInput>;
}

export interface CompanyCreateManyWithoutTherapeuticsInput {
  create?: Maybe<
    | CompanyCreateWithoutTherapeuticsInput[]
    | CompanyCreateWithoutTherapeuticsInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutTherapeuticsInput {
  id?: Maybe<ID_Input>;
  maintainer?: Maybe<String>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompanyInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimCreateManyWithoutCompanyInput>;
}

export interface TherapeuticUpdateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyWithoutTherapeuticsInput>;
}

export interface CompanyUpdateManyWithoutTherapeuticsInput {
  create?: Maybe<
    | CompanyCreateWithoutTherapeuticsInput[]
    | CompanyCreateWithoutTherapeuticsInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutTherapeuticsInput[]
    | CompanyUpdateWithWhereUniqueWithoutTherapeuticsInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutTherapeuticsInput[]
    | CompanyUpsertWithWhereUniqueWithoutTherapeuticsInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutTherapeuticsInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutTherapeuticsDataInput;
}

export interface CompanyUpdateWithoutTherapeuticsDataInput {
  maintainer?: Maybe<String>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompanyInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
  claims?: Maybe<ClaimUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutTherapeuticsInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutTherapeuticsDataInput;
  create: CompanyCreateWithoutTherapeuticsInput;
}

export interface TherapeuticUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface BidSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BidWhereInput>;
  AND?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  OR?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  NOT?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
}

export interface ClaimSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClaimWhereInput>;
  AND?: Maybe<ClaimSubscriptionWhereInput[] | ClaimSubscriptionWhereInput>;
  OR?: Maybe<ClaimSubscriptionWhereInput[] | ClaimSubscriptionWhereInput>;
  NOT?: Maybe<ClaimSubscriptionWhereInput[] | ClaimSubscriptionWhereInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface RegionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegionWhereInput>;
  AND?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  OR?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  NOT?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ServiceWhereInput>;
  AND?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  OR?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  NOT?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
}

export interface ServiceItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ServiceItemWhereInput>;
  AND?: Maybe<
    ServiceItemSubscriptionWhereInput[] | ServiceItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    ServiceItemSubscriptionWhereInput[] | ServiceItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ServiceItemSubscriptionWhereInput[] | ServiceItemSubscriptionWhereInput
  >;
}

export interface SpecialtySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpecialtyWhereInput>;
  AND?: Maybe<
    SpecialtySubscriptionWhereInput[] | SpecialtySubscriptionWhereInput
  >;
  OR?: Maybe<
    SpecialtySubscriptionWhereInput[] | SpecialtySubscriptionWhereInput
  >;
  NOT?: Maybe<
    SpecialtySubscriptionWhereInput[] | SpecialtySubscriptionWhereInput
  >;
}

export interface SpecialtyItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpecialtyItemWhereInput>;
  AND?: Maybe<
    SpecialtyItemSubscriptionWhereInput[] | SpecialtyItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    SpecialtyItemSubscriptionWhereInput[] | SpecialtyItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SpecialtyItemSubscriptionWhereInput[] | SpecialtyItemSubscriptionWhereInput
  >;
}

export interface StudySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudyWhereInput>;
  AND?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
  OR?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
  NOT?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
}

export interface TherapeuticSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TherapeuticWhereInput>;
  AND?: Maybe<
    TherapeuticSubscriptionWhereInput[] | TherapeuticSubscriptionWhereInput
  >;
  OR?: Maybe<
    TherapeuticSubscriptionWhereInput[] | TherapeuticSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TherapeuticSubscriptionWhereInput[] | TherapeuticSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Bid {
  id: ID_Output;
  bid_amount: Float;
  is_approved: Boolean;
}

export interface BidPromise extends Promise<Bid>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
  study: <T = StudyPromise>() => T;
}

export interface BidSubscription
  extends Promise<AsyncIterator<Bid>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  bid_amount: () => Promise<AsyncIterator<Float>>;
  is_approved: () => Promise<AsyncIterator<Boolean>>;
  study: <T = StudySubscription>() => T;
}

export interface BidNullablePromise extends Promise<Bid | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
  study: <T = StudyPromise>() => T;
}

export interface Company {
  id: ID_Output;
  maintainer?: String;
  name: String;
  email?: String;
  phases: Phase[];
  logoURL?: String;
  website?: String;
  linkedin?: String;
  overview?: String;
  headquarters?: String;
  companySize?: CompanySize;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  maintainer: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phases: () => Promise<Phase[]>;
  logoURL: () => Promise<String>;
  website: () => Promise<String>;
  linkedin: () => Promise<String>;
  overview: () => Promise<String>;
  headquarters: () => Promise<String>;
  companySize: () => Promise<CompanySize>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regions: <T = FragmentableArray<Region>>(args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  therapeutics: <T = FragmentableArray<Therapeutic>>(args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studies: <T = FragmentableArray<Study>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  claims: <T = FragmentableArray<Claim>>(args?: {
    where?: ClaimWhereInput;
    orderBy?: ClaimOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  maintainer: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phases: () => Promise<AsyncIterator<Phase[]>>;
  logoURL: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  linkedin: () => Promise<AsyncIterator<String>>;
  overview: () => Promise<AsyncIterator<String>>;
  headquarters: () => Promise<AsyncIterator<String>>;
  companySize: () => Promise<AsyncIterator<CompanySize>>;
  services: <T = Promise<AsyncIterator<ServiceSubscription>>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regions: <T = Promise<AsyncIterator<RegionSubscription>>>(args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  therapeutics: <T = Promise<AsyncIterator<TherapeuticSubscription>>>(args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studies: <T = Promise<AsyncIterator<StudySubscription>>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = Promise<AsyncIterator<BidSubscription>>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  claims: <T = Promise<AsyncIterator<ClaimSubscription>>>(args?: {
    where?: ClaimWhereInput;
    orderBy?: ClaimOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  maintainer: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phases: () => Promise<Phase[]>;
  logoURL: () => Promise<String>;
  website: () => Promise<String>;
  linkedin: () => Promise<String>;
  overview: () => Promise<String>;
  headquarters: () => Promise<String>;
  companySize: () => Promise<CompanySize>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regions: <T = FragmentableArray<Region>>(args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  therapeutics: <T = FragmentableArray<Therapeutic>>(args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studies: <T = FragmentableArray<Study>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  claims: <T = FragmentableArray<Claim>>(args?: {
    where?: ClaimWhereInput;
    orderBy?: ClaimOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Service {
  id: ID_Output;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>;
  info: <T = ServiceItemPromise>() => T;
  company: <T = CompanyPromise>() => T;
  specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  info: <T = ServiceItemSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  specialties: <T = Promise<AsyncIterator<SpecialtySubscription>>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ServiceNullablePromise
  extends Promise<Service | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  info: <T = ServiceItemPromise>() => T;
  company: <T = CompanyPromise>() => T;
  specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ServiceItem {
  id: ID_Output;
  name: String;
}

export interface ServiceItemPromise extends Promise<ServiceItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ServiceItemSubscription
  extends Promise<AsyncIterator<ServiceItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ServiceItemNullablePromise
  extends Promise<ServiceItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface Specialty {
  id: ID_Output;
}

export interface SpecialtyPromise extends Promise<Specialty>, Fragmentable {
  id: () => Promise<ID_Output>;
  info: <T = SpecialtyItemPromise>() => T;
  service: <T = ServicePromise>() => T;
  sub_specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SpecialtySubscription
  extends Promise<AsyncIterator<Specialty>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  info: <T = SpecialtyItemSubscription>() => T;
  service: <T = ServiceSubscription>() => T;
  sub_specialties: <T = Promise<AsyncIterator<SpecialtySubscription>>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SpecialtyNullablePromise
  extends Promise<Specialty | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  info: <T = SpecialtyItemPromise>() => T;
  service: <T = ServicePromise>() => T;
  sub_specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SpecialtyItem {
  id: ID_Output;
  name: String;
}

export interface SpecialtyItemPromise
  extends Promise<SpecialtyItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SpecialtyItemSubscription
  extends Promise<AsyncIterator<SpecialtyItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SpecialtyItemNullablePromise
  extends Promise<SpecialtyItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface Region {
  id: ID_Output;
  name: String;
}

export interface RegionPromise extends Promise<Region>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionSubscription
  extends Promise<AsyncIterator<Region>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionNullablePromise
  extends Promise<Region | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Therapeutic {
  id: ID_Output;
  name: String;
}

export interface TherapeuticPromise extends Promise<Therapeutic>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TherapeuticSubscription
  extends Promise<AsyncIterator<Therapeutic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TherapeuticNullablePromise
  extends Promise<Therapeutic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Study {
  id: ID_Output;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeOutput;
  status: String;
}

export interface StudyPromise extends Promise<Study>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface StudySubscription
  extends Promise<AsyncIterator<Study>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  protocol_number: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  phase: () => Promise<AsyncIterator<Int>>;
  services: () => Promise<AsyncIterator<Int>>;
  modified_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
}

export interface StudyNullablePromise
  extends Promise<Study | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface Claim {
  id: ID_Output;
  user: String;
  email: String;
  name: String;
  pending: Boolean;
  approved: Boolean;
}

export interface ClaimPromise extends Promise<Claim>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  pending: () => Promise<Boolean>;
  approved: () => Promise<Boolean>;
}

export interface ClaimSubscription
  extends Promise<AsyncIterator<Claim>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  pending: () => Promise<AsyncIterator<Boolean>>;
  approved: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClaimNullablePromise
  extends Promise<Claim | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  pending: () => Promise<Boolean>;
  approved: () => Promise<Boolean>;
}

export interface BidConnection {
  pageInfo: PageInfo;
  edges: BidEdge[];
}

export interface BidConnectionPromise
  extends Promise<BidConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BidEdge>>() => T;
  aggregate: <T = AggregateBidPromise>() => T;
}

export interface BidConnectionSubscription
  extends Promise<AsyncIterator<BidConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BidEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBidSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BidEdge {
  node: Bid;
  cursor: String;
}

export interface BidEdgePromise extends Promise<BidEdge>, Fragmentable {
  node: <T = BidPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BidEdgeSubscription
  extends Promise<AsyncIterator<BidEdge>>,
    Fragmentable {
  node: <T = BidSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBid {
  count: Int;
}

export interface AggregateBidPromise
  extends Promise<AggregateBid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBidSubscription
  extends Promise<AsyncIterator<AggregateBid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClaimConnection {
  pageInfo: PageInfo;
  edges: ClaimEdge[];
}

export interface ClaimConnectionPromise
  extends Promise<ClaimConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClaimEdge>>() => T;
  aggregate: <T = AggregateClaimPromise>() => T;
}

export interface ClaimConnectionSubscription
  extends Promise<AsyncIterator<ClaimConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClaimEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClaimSubscription>() => T;
}

export interface ClaimEdge {
  node: Claim;
  cursor: String;
}

export interface ClaimEdgePromise extends Promise<ClaimEdge>, Fragmentable {
  node: <T = ClaimPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClaimEdgeSubscription
  extends Promise<AsyncIterator<ClaimEdge>>,
    Fragmentable {
  node: <T = ClaimSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClaim {
  count: Int;
}

export interface AggregateClaimPromise
  extends Promise<AggregateClaim>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClaimSubscription
  extends Promise<AsyncIterator<AggregateClaim>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegionConnection {
  pageInfo: PageInfo;
  edges: RegionEdge[];
}

export interface RegionConnectionPromise
  extends Promise<RegionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegionEdge>>() => T;
  aggregate: <T = AggregateRegionPromise>() => T;
}

export interface RegionConnectionSubscription
  extends Promise<AsyncIterator<RegionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegionSubscription>() => T;
}

export interface RegionEdge {
  node: Region;
  cursor: String;
}

export interface RegionEdgePromise extends Promise<RegionEdge>, Fragmentable {
  node: <T = RegionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegionEdgeSubscription
  extends Promise<AsyncIterator<RegionEdge>>,
    Fragmentable {
  node: <T = RegionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegion {
  count: Int;
}

export interface AggregateRegionPromise
  extends Promise<AggregateRegion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegionSubscription
  extends Promise<AsyncIterator<AggregateRegion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServiceItemConnection {
  pageInfo: PageInfo;
  edges: ServiceItemEdge[];
}

export interface ServiceItemConnectionPromise
  extends Promise<ServiceItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceItemEdge>>() => T;
  aggregate: <T = AggregateServiceItemPromise>() => T;
}

export interface ServiceItemConnectionSubscription
  extends Promise<AsyncIterator<ServiceItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceItemSubscription>() => T;
}

export interface ServiceItemEdge {
  node: ServiceItem;
  cursor: String;
}

export interface ServiceItemEdgePromise
  extends Promise<ServiceItemEdge>,
    Fragmentable {
  node: <T = ServiceItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceItemEdgeSubscription
  extends Promise<AsyncIterator<ServiceItemEdge>>,
    Fragmentable {
  node: <T = ServiceItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateServiceItem {
  count: Int;
}

export interface AggregateServiceItemPromise
  extends Promise<AggregateServiceItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceItemSubscription
  extends Promise<AsyncIterator<AggregateServiceItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialtyConnection {
  pageInfo: PageInfo;
  edges: SpecialtyEdge[];
}

export interface SpecialtyConnectionPromise
  extends Promise<SpecialtyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpecialtyEdge>>() => T;
  aggregate: <T = AggregateSpecialtyPromise>() => T;
}

export interface SpecialtyConnectionSubscription
  extends Promise<AsyncIterator<SpecialtyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecialtyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecialtySubscription>() => T;
}

export interface SpecialtyEdge {
  node: Specialty;
  cursor: String;
}

export interface SpecialtyEdgePromise
  extends Promise<SpecialtyEdge>,
    Fragmentable {
  node: <T = SpecialtyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpecialtyEdgeSubscription
  extends Promise<AsyncIterator<SpecialtyEdge>>,
    Fragmentable {
  node: <T = SpecialtySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSpecialty {
  count: Int;
}

export interface AggregateSpecialtyPromise
  extends Promise<AggregateSpecialty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecialtySubscription
  extends Promise<AsyncIterator<AggregateSpecialty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialtyItemConnection {
  pageInfo: PageInfo;
  edges: SpecialtyItemEdge[];
}

export interface SpecialtyItemConnectionPromise
  extends Promise<SpecialtyItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpecialtyItemEdge>>() => T;
  aggregate: <T = AggregateSpecialtyItemPromise>() => T;
}

export interface SpecialtyItemConnectionSubscription
  extends Promise<AsyncIterator<SpecialtyItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecialtyItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecialtyItemSubscription>() => T;
}

export interface SpecialtyItemEdge {
  node: SpecialtyItem;
  cursor: String;
}

export interface SpecialtyItemEdgePromise
  extends Promise<SpecialtyItemEdge>,
    Fragmentable {
  node: <T = SpecialtyItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpecialtyItemEdgeSubscription
  extends Promise<AsyncIterator<SpecialtyItemEdge>>,
    Fragmentable {
  node: <T = SpecialtyItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSpecialtyItem {
  count: Int;
}

export interface AggregateSpecialtyItemPromise
  extends Promise<AggregateSpecialtyItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecialtyItemSubscription
  extends Promise<AsyncIterator<AggregateSpecialtyItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudyConnection {
  pageInfo: PageInfo;
  edges: StudyEdge[];
}

export interface StudyConnectionPromise
  extends Promise<StudyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudyEdge>>() => T;
  aggregate: <T = AggregateStudyPromise>() => T;
}

export interface StudyConnectionSubscription
  extends Promise<AsyncIterator<StudyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudySubscription>() => T;
}

export interface StudyEdge {
  node: Study;
  cursor: String;
}

export interface StudyEdgePromise extends Promise<StudyEdge>, Fragmentable {
  node: <T = StudyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudyEdgeSubscription
  extends Promise<AsyncIterator<StudyEdge>>,
    Fragmentable {
  node: <T = StudySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudy {
  count: Int;
}

export interface AggregateStudyPromise
  extends Promise<AggregateStudy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudySubscription
  extends Promise<AsyncIterator<AggregateStudy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TherapeuticConnection {
  pageInfo: PageInfo;
  edges: TherapeuticEdge[];
}

export interface TherapeuticConnectionPromise
  extends Promise<TherapeuticConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TherapeuticEdge>>() => T;
  aggregate: <T = AggregateTherapeuticPromise>() => T;
}

export interface TherapeuticConnectionSubscription
  extends Promise<AsyncIterator<TherapeuticConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TherapeuticEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTherapeuticSubscription>() => T;
}

export interface TherapeuticEdge {
  node: Therapeutic;
  cursor: String;
}

export interface TherapeuticEdgePromise
  extends Promise<TherapeuticEdge>,
    Fragmentable {
  node: <T = TherapeuticPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TherapeuticEdgeSubscription
  extends Promise<AsyncIterator<TherapeuticEdge>>,
    Fragmentable {
  node: <T = TherapeuticSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTherapeutic {
  count: Int;
}

export interface AggregateTherapeuticPromise
  extends Promise<AggregateTherapeutic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTherapeuticSubscription
  extends Promise<AsyncIterator<AggregateTherapeutic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BidSubscriptionPayload {
  mutation: MutationType;
  node: Bid;
  updatedFields: String[];
  previousValues: BidPreviousValues;
}

export interface BidSubscriptionPayloadPromise
  extends Promise<BidSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BidPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BidPreviousValuesPromise>() => T;
}

export interface BidSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BidSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BidSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BidPreviousValuesSubscription>() => T;
}

export interface BidPreviousValues {
  id: ID_Output;
  bid_amount: Float;
  is_approved: Boolean;
}

export interface BidPreviousValuesPromise
  extends Promise<BidPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
}

export interface BidPreviousValuesSubscription
  extends Promise<AsyncIterator<BidPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bid_amount: () => Promise<AsyncIterator<Float>>;
  is_approved: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClaimSubscriptionPayload {
  mutation: MutationType;
  node: Claim;
  updatedFields: String[];
  previousValues: ClaimPreviousValues;
}

export interface ClaimSubscriptionPayloadPromise
  extends Promise<ClaimSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClaimPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClaimPreviousValuesPromise>() => T;
}

export interface ClaimSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClaimSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClaimSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClaimPreviousValuesSubscription>() => T;
}

export interface ClaimPreviousValues {
  id: ID_Output;
  user: String;
  email: String;
  name: String;
  pending: Boolean;
  approved: Boolean;
}

export interface ClaimPreviousValuesPromise
  extends Promise<ClaimPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  pending: () => Promise<Boolean>;
  approved: () => Promise<Boolean>;
}

export interface ClaimPreviousValuesSubscription
  extends Promise<AsyncIterator<ClaimPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  pending: () => Promise<AsyncIterator<Boolean>>;
  approved: () => Promise<AsyncIterator<Boolean>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  maintainer?: String;
  name: String;
  email?: String;
  phases: Phase[];
  logoURL?: String;
  website?: String;
  linkedin?: String;
  overview?: String;
  headquarters?: String;
  companySize?: CompanySize;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  maintainer: () => Promise<String>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phases: () => Promise<Phase[]>;
  logoURL: () => Promise<String>;
  website: () => Promise<String>;
  linkedin: () => Promise<String>;
  overview: () => Promise<String>;
  headquarters: () => Promise<String>;
  companySize: () => Promise<CompanySize>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  maintainer: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phases: () => Promise<AsyncIterator<Phase[]>>;
  logoURL: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  linkedin: () => Promise<AsyncIterator<String>>;
  overview: () => Promise<AsyncIterator<String>>;
  headquarters: () => Promise<AsyncIterator<String>>;
  companySize: () => Promise<AsyncIterator<CompanySize>>;
}

export interface RegionSubscriptionPayload {
  mutation: MutationType;
  node: Region;
  updatedFields: String[];
  previousValues: RegionPreviousValues;
}

export interface RegionSubscriptionPayloadPromise
  extends Promise<RegionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegionPreviousValuesPromise>() => T;
}

export interface RegionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegionPreviousValuesSubscription>() => T;
}

export interface RegionPreviousValues {
  id: ID_Output;
  name: String;
}

export interface RegionPreviousValuesPromise
  extends Promise<RegionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RegionPreviousValuesSubscription
  extends Promise<AsyncIterator<RegionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface ServicePreviousValues {
  id: ID_Output;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ServiceItemSubscriptionPayload {
  mutation: MutationType;
  node: ServiceItem;
  updatedFields: String[];
  previousValues: ServiceItemPreviousValues;
}

export interface ServiceItemSubscriptionPayloadPromise
  extends Promise<ServiceItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServiceItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServiceItemPreviousValuesPromise>() => T;
}

export interface ServiceItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServiceItemPreviousValuesSubscription>() => T;
}

export interface ServiceItemPreviousValues {
  id: ID_Output;
  name: String;
}

export interface ServiceItemPreviousValuesPromise
  extends Promise<ServiceItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ServiceItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ServiceItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SpecialtySubscriptionPayload {
  mutation: MutationType;
  node: Specialty;
  updatedFields: String[];
  previousValues: SpecialtyPreviousValues;
}

export interface SpecialtySubscriptionPayloadPromise
  extends Promise<SpecialtySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecialtyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecialtyPreviousValuesPromise>() => T;
}

export interface SpecialtySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecialtySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecialtySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecialtyPreviousValuesSubscription>() => T;
}

export interface SpecialtyPreviousValues {
  id: ID_Output;
}

export interface SpecialtyPreviousValuesPromise
  extends Promise<SpecialtyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SpecialtyPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecialtyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SpecialtyItemSubscriptionPayload {
  mutation: MutationType;
  node: SpecialtyItem;
  updatedFields: String[];
  previousValues: SpecialtyItemPreviousValues;
}

export interface SpecialtyItemSubscriptionPayloadPromise
  extends Promise<SpecialtyItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecialtyItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecialtyItemPreviousValuesPromise>() => T;
}

export interface SpecialtyItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecialtyItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecialtyItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecialtyItemPreviousValuesSubscription>() => T;
}

export interface SpecialtyItemPreviousValues {
  id: ID_Output;
  name: String;
}

export interface SpecialtyItemPreviousValuesPromise
  extends Promise<SpecialtyItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SpecialtyItemPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecialtyItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StudySubscriptionPayload {
  mutation: MutationType;
  node: Study;
  updatedFields: String[];
  previousValues: StudyPreviousValues;
}

export interface StudySubscriptionPayloadPromise
  extends Promise<StudySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudyPreviousValuesPromise>() => T;
}

export interface StudySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudyPreviousValuesSubscription>() => T;
}

export interface StudyPreviousValues {
  id: ID_Output;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeOutput;
  status: String;
}

export interface StudyPreviousValuesPromise
  extends Promise<StudyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
}

export interface StudyPreviousValuesSubscription
  extends Promise<AsyncIterator<StudyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  protocol_number: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  phase: () => Promise<AsyncIterator<Int>>;
  services: () => Promise<AsyncIterator<Int>>;
  modified_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface TherapeuticSubscriptionPayload {
  mutation: MutationType;
  node: Therapeutic;
  updatedFields: String[];
  previousValues: TherapeuticPreviousValues;
}

export interface TherapeuticSubscriptionPayloadPromise
  extends Promise<TherapeuticSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TherapeuticPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TherapeuticPreviousValuesPromise>() => T;
}

export interface TherapeuticSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TherapeuticSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TherapeuticSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TherapeuticPreviousValuesSubscription>() => T;
}

export interface TherapeuticPreviousValues {
  id: ID_Output;
  name: String;
}

export interface TherapeuticPreviousValuesPromise
  extends Promise<TherapeuticPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TherapeuticPreviousValuesSubscription
  extends Promise<AsyncIterator<TherapeuticPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Claim",
    embedded: false
  },
  {
    name: "ServiceItem",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "SpecialtyItem",
    embedded: false
  },
  {
    name: "Specialty",
    embedded: false
  },
  {
    name: "Region",
    embedded: false
  },
  {
    name: "Therapeutic",
    embedded: false
  },
  {
    name: "CompanySize",
    embedded: false
  },
  {
    name: "Phase",
    embedded: false
  },
  {
    name: "Bid",
    embedded: false
  },
  {
    name: "Study",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
